<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端组件化 | ekoneko.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言我的公司从去年开始把一些项目陆陆续续的从五花八门的设计迁移到了 react 框架. 结构上做到了统一, 目前, 我们的项目是多个团队在同一框架下并行开发应用. 各个应用运行在同一个单页面内, 并且共同维护一套公共组件库. 随着业务发展组件暴露出来了一系列的问题, 例如未经测试完成的组件修改会被其他应用捎带上线, 以及组件的 break change 会带来意料之外的问题等. 依赖于组件的需求有">
<meta name="keywords" content="react,engineering,modules">
<meta property="og:type" content="article">
<meta property="og:title" content="前端组件化">
<meta property="og:url" content="http://ekoneko.github.io/blog/engineering/a-plan-of-web-components/index.html">
<meta property="og:site_name" content="ekoneko.github.io">
<meta property="og:description" content="前言我的公司从去年开始把一些项目陆陆续续的从五花八门的设计迁移到了 react 框架. 结构上做到了统一, 目前, 我们的项目是多个团队在同一框架下并行开发应用. 各个应用运行在同一个单页面内, 并且共同维护一套公共组件库. 随着业务发展组件暴露出来了一系列的问题, 例如未经测试完成的组件修改会被其他应用捎带上线, 以及组件的 break change 会带来意料之外的问题等. 依赖于组件的需求有">
<meta property="og:updated_time" content="2017-09-12T04:04:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端组件化">
<meta name="twitter:description" content="前言我的公司从去年开始把一些项目陆陆续续的从五花八门的设计迁移到了 react 框架. 结构上做到了统一, 目前, 我们的项目是多个团队在同一框架下并行开发应用. 各个应用运行在同一个单页面内, 并且共同维护一套公共组件库. 随着业务发展组件暴露出来了一系列的问题, 例如未经测试完成的组件修改会被其他应用捎带上线, 以及组件的 break change 会带来意料之外的问题等. 依赖于组件的需求有">
  
    <link rel="alternate" href="/atom.xml" title="ekoneko.github.io" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">ekoneko.github.io</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ekoneko.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-a-plan-of-web-components" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/engineering/a-plan-of-web-components/" class="article-date">
  <time datetime="2017-09-04T13:22:50.000Z" itemprop="datePublished">2017-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/engineering/">engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端组件化
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的公司从去年开始把一些项目陆陆续续的从五花八门的设计迁移到了 react 框架. 结构上做到了统一, 目前, 我们的项目是多个团队在同一框架下并行开发应用. 各个应用运行在同一个单页面内, 并且共同维护一套公共组件库.</p>
<p>随着业务发展组件暴露出来了一系列的问题, 例如未经测试完成的组件修改会被其他应用捎带上线, 以及组件的 break change 会带来意料之外的问题等. 依赖于组件的需求有时也会因人员调度问题阻塞正常迭代.</p>
<p>针对以上问题, 我最近正着手于新一套组件的规范与设计. 新组件既能做到与目前组件同时使用, 也能够解决上述的问题并且带来更好的开发体验与效率.</p>
<p>以下的正文是我和公司内前端团队 Review 的组件提案, 其中删减了一些公司内的具体业务.</p>
<hr>
<h2 id="新旧组件的概述"><a href="#新旧组件的概述" class="headerlink" title="新旧组件的概述"></a>新旧组件的概述</h2><h3 id="旧组件的问题"><a href="#旧组件的问题" class="headerlink" title="旧组件的问题"></a>旧组件的问题</h3><h4 id="1-规范混乱"><a href="#1-规范混乱" class="headerlink" title="1. 规范混乱"></a>1. 规范混乱</h4><p>旧组件的项目创建后仅仅是由前端团队一方进行维护. 产品设计团队的的样式标准进行过多轮迭代, 但与前端团队缺乏单独针对组件的沟通. 以至于旧组件做不到开箱即用, 给日后开发带来了额外工作量.</p>
<p>不同的应用团队对于组件的维护的积极性也不一致, 加上没有一个统一的 CSS 书写规范, 各个应用中存在大量对组件样式的复写. 这对组件维护带来了极大的风险, 组件样式的统一调整可能会导致各个应用中复写的样式产生不可预期的后果.</p>
<h4 id="2-文档缺失"><a href="#2-文档缺失" class="headerlink" title="2. 文档缺失"></a>2. 文档缺失</h4><p>旧组件对文档没有要求. 大部分组件并没有明确的使用指南与参数列表. 一些使用者仅仅是在其他应用中寻找相似的调用方式, 对于组件功能并没有清晰的认识, 更甚至会采用一些侵入式的方式去实现组件既有的功能.</p>
<p>对于简单且容易实现的组件, 开发者如果不能明确的知道组件库中存在, 往往会自己重新实现一份, 造成了额外的成本浪费.</p>
<p>另一方面, 缺少文档的组件也对后期维护带来了困扰. 其他人修改时也可能理不清组件作者的初衷.</p>
<h4 id="3-业务耦合"><a href="#3-业务耦合" class="headerlink" title="3. 业务耦合"></a>3. 业务耦合</h4><p>旧组件的开发往往伴随业务迭代, 有些组件中包含了应用中的数据请求. 例如在 A 应用开发过程创建的组件, 可能其中包含了 /apis/A/request 的请求, 那么当 B 应用 开发环境调用时, 就必须部署 A 应用的服务. 给开发测试带来了不便.</p>
<h4 id="4-版本依赖"><a href="#4-版本依赖" class="headerlink" title="4. 版本依赖"></a>4. 版本依赖</h4><p>旧版组件集中在单一仓库中, 以 npm 模块的方式被各个应用引入, 组件的修改与测试依赖于具体的应用. 如果 A 应用迭代开发阶段正在修改的 a 组件处于 unstable 状态, 当 B 应用需要携带组件发布时, 就比较容易将 unstable 的 A 组件”顺带”发布上线.</p>
<p>当发布时 A, B 应用所引入的组件版本不一致(为了确保依赖的准确性, 我们没有使用 semver 的泛匹配)时, npm 会分别打包两个版本的组件, 导致最终生成的 bundle 文件体积很大.</p>
<h4 id="5-人员协调困难"><a href="#5-人员协调困难" class="headerlink" title="5. 人员协调困难"></a>5. 人员协调困难</h4><p>有的组件工作会 block 业务的正常迭代. 公司现有资源环境下很难投入充足的人员去专职维护组件, 并且这也是十分浪费的一种行为. 因而有时候会导致业务发布的延期或伴随组件问题的发布.</p>
<h3 id="新组件的特性"><a href="#新组件的特性" class="headerlink" title="新组件的特性"></a>新组件的特性</h3><p>新版组件是在旧组件的基础上针对上述的问题而设计的新一代组件库.</p>
<a id="more"></a>
<ol>
<li>组件的一生始终保持与产品设计的效果一致. 统一维护样式设计文档, 产品需求与代码. 保证每一步变化可被追踪.</li>
<li>采用全新的 class 前缀, 不对过去的样式代码造成破坏. 一方面会跟随设计更新, 另一方面通过约定好的 CSS 规范, 保证各个业务项目尽量不对组件样式进行复写. 降低组件与业务代码的耦合性.</li>
<li>对外提供演示环境. 并要求提交 code review 前, 先要通过接口设计文档的 review.</li>
<li>新版组件不会集中于一个组件库中, 每一个功能会有自己的仓库, 并通过一个统一的仓库进行版本管理, 对外提供统一版本的组件.</li>
<li>组件的维护方式会更加开放(下文会有详细描述)</li>
</ol>
<h3 id="迁移成本"><a href="#迁移成本" class="headerlink" title="迁移成本"></a>迁移成本</h3><p>新旧组件采用不同的 class 前缀. 新组建的引入不会对原有样式进行破坏, 也不会轻易受到过去样式的影响.</p>
<p>构建环节只会引入应用使用到的组件, 不会整包打入. 对于构建体积不会有太大的影响.</p>
<p>二者可以做到相互兼容, 只需要伴随迭代慢慢减少对旧组件的依赖即可.</p>
<h2 id="组件的开发与维护"><a href="#组件的开发与维护" class="headerlink" title="组件的开发与维护"></a>组件的开发与维护</h2><h3 id="统一需求维护"><a href="#统一需求维护" class="headerlink" title="统一需求维护"></a>统一需求维护</h3><p>公共组件是由代码 + 需求组成的. 每一次的组件变更应该始于需求(or bug)的提出, 终于需求(or bug)的关闭.</p>
<p>我们在 jira 平台上维护需求与 bug, 以及内部的代码管理平台维护 code. 每一个 merge request 需要有与之对应的 jira ID.</p>
<p>我们可以通过一些自动化工具来对二者进行关联. 确保所有的变更需求可以被追踪.</p>
<h3 id="组件代码维护"><a href="#组件代码维护" class="headerlink" title="组件代码维护"></a>组件代码维护</h3><p>所有人都可以参与组件的开发(也希望所有人都参与).</p>
<h4 id="阻塞业务开发的组件维护"><a href="#阻塞业务开发的组件维护" class="headerlink" title="阻塞业务开发的组件维护"></a>阻塞业务开发的组件维护</h4><p>对于与业务同步并可能阻塞业务开发的组件, 例如如下场合:</p>
<ol>
<li>需求的组件还不存在, 但功能与业务独立, 并有可能用于其他项目中</li>
<li>组件已存在, 但业务需要新增功能, 如功能扩展, 返回更多的内容, 界面调整等</li>
<li>组件已存在, 但存在 bug, 并影响业务的后续开发或发布</li>
</ol>
<p>对于这一类场景, 为了不影响业务的正常开发, 建议业务的开发者人员与大家进行讨论后, 自己修改或新建组件.</p>
<p>这看起来不太合理, 但有理由这么做:</p>
<ol>
<li>组件的开发与使用是相对的, 业务开发的过程中, 有可能使用到别的业务线已开发完成的组件, 也可以贡献自己的代码让其他人从中获利, 如此持续下去, 组件库就会越来越丰富, 更多的业务逻辑可以由组件代理实现.</li>
<li>共同维护的组件也意味着共同的更新, bug 修复和测试. 同一个组件的问题, 只需要修改一遍, 其他应用只要更新组件就可以坐享其成. 即使组件中带来了问题, 也有更多双眼睛可以及时的找到问题, 并修复.</li>
<li>组件会比业务逻辑经历更多的讨论与 Review. 可能会比开发人员在业务中一个人想到的代码更加健壮/易读/通用. 开发人员也可以在其过程中成长并获得成就感.</li>
<li>组件的封装有利于解耦业务逻辑, 并且比起非组件的代码出错的可能性更少(参考上一条), 反而可以提高业务开发的整体效率.</li>
</ol>
<h4 id="常规组件维护"><a href="#常规组件维护" class="headerlink" title="常规组件维护"></a>常规组件维护</h4><p>对于不那么紧急的组件, 比如</p>
<ol>
<li>常用功能的提取</li>
<li>组件的调整与优化</li>
<li>解决组件中的 TODO 和 FIXME</li>
</ol>
<p>这一类型的组件会展示在一个公开的面板上, 任何开发人员可以认领问题并处理. 这种开发模式比较接近一些开源社区的代码维护. 使得开发人员的时间得到充分利用, 并且对个人的成长也有所帮助.</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>记录需求: 将需求拆分成需要组件实现的关键点并记录</li>
<li>设计文档: 基于需求设计出组件参数调整及响应的变化, 及实现思路</li>
<li>设计文档 Review / 讨论</li>
<li>编码</li>
<li>编写相对应的 demo</li>
<li>Review</li>
<li>代码 submit 后发布一个 beta 版本, 更新演示环境并通知测试</li>
<li>Publish</li>
</ol>
<h2 id="组件的设计"><a href="#组件的设计" class="headerlink" title="组件的设计"></a>组件的设计</h2><h3 id="什么样的文件应该被抽离为公共组件"><a href="#什么样的文件应该被抽离为公共组件" class="headerlink" title="什么样的文件应该被抽离为公共组件"></a>什么样的文件应该被抽离为公共组件</h3><h4 id="1-普通组件"><a href="#1-普通组件" class="headerlink" title="1. 普通组件"></a>1. 普通组件</h4><p>普通组件可能是对一段样式的封装(例如 Button), 也可能是对一类交互逻辑的封装 (比如 DatePicker)</p>
<h4 id="2-页面布局"><a href="#2-页面布局" class="headerlink" title="2. 页面布局"></a>2. 页面布局</h4><p>比如一个页面是左右分栏的布局, 可能被应用于多个地方, 那就可以抽象为以下的形式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;HorizonLayout</div><div class="line">    left=&#123;leftElement&#125;</div><div class="line">    right=&#123;rightElement&#125;</div><div class="line">/&gt;</div></pre></td></tr></table></figure>
<h4 id="3-逻辑组件"><a href="#3-逻辑组件" class="headerlink" title="3. 逻辑组件"></a>3. 逻辑组件</h4><p>比如说编辑器输出的文本, 考虑到和编辑器本身是强关联的, 当编辑器功能调整时, 输出的内容也可能需要在渲染时进行统一 format.  如果能提前封装好 <editorcontent> 在后续的修改时就可以 write once work everywhere.</editorcontent></p>
<p>组件是为了更好的开发与维护, 并不仅仅局限于上述几点, 像是埋点等逻辑也可以作为一个组件独立封装.</p>
<h3 id="组件的提纯与抽象"><a href="#组件的提纯与抽象" class="headerlink" title="组件的提纯与抽象"></a>组件的提纯与抽象</h3><h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h4><p>组件应该保持功能的独立性, 不应该受到业务中上下文或是副作用(side effect) 的影响. 对于组件中的网络请求, 可以将请求提取到组件之外完成, 将请求的数据传入组件. 对于一些与 server 端强相关的组件(比如说 MemberSelector), 组件内的 ajax 请求地址应该尽可能的放在公共接口中 (<code>/api/common/...</code>)</p>
<h4 id="单一"><a href="#单一" class="headerlink" title="单一"></a>单一</h4><p>独立的功能应该尽可能放在最小可用的单位(下文称之为单元组件)里. 例如 InputPassword, InputSearch 可能都会在 Input 的基础上执行当 onKeyPress 时执行警告或 autoComplete. 那么对于 onKeyPress 的截流(throttle) 在公用的 Input 上实现可以更好的实现复用.</p>
<p>有些时候开发可能受到业务中思维惯性的影响, 不能轻易的分清组件的最小单位, 这种时候冷静下来转换一下思维或是和其他人讨论会是一个很好的选择.</p>
<h4 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h4><p>组件既可以拆解成单元组件, 也可以将多个小组件统一拼装成一个复合组件. 例如业务中用到的 <code>MemberSelector</code> 与 <code>MemberPicker</code>. 后者就是在前者的基础上, 封装成为了点击弹出 <code>Modal</code> 的形式.</p>
<p>很多场合中, 使用人员都会把许多组件作为一个整体去使用, 复合组件的封装可以让使用人员调用更加轻易, 并且不用深入了解每一个单元组件的调用细节.</p>
<h4 id="可读"><a href="#可读" class="headerlink" title="可读"></a>可读</h4><p>组件应该告诉用户自己如何使用. 通过完善的文档, 用户可以了解组件的基本用法与 props 定义. 组件内部定义好的 <a href="https://facebook.github.io/react/docs/typechecking-with-proptypes.html" target="_blank" rel="external">prop-type</a> 可以让 IDE 调用组件时提供更好的补全, 并当  props 类型出错或是required 的 prop 没有传递时抛出警告.</p>
<h2 id="组件发布"><a href="#组件发布" class="headerlink" title="组件发布"></a>组件发布</h2><h3 id="独立代码仓库"><a href="#独立代码仓库" class="headerlink" title="独立代码仓库"></a>独立代码仓库</h3><p>如同之前提到的, 组件放在同一个仓库中并行修改时, 必须通过一些特殊手段去确保未经测试通过的修改不会影响到线上用户. 实际操作过程中, 这些 “特殊手段”(例如通过 flag 开关控制代码执行等), 非常不方便, 并且也容易带来潜在的 bug.</p>
<p>观察目前前端流行的组件库 <code>ant.design</code>. 其中大部分实现都封装在 <code>rc-components</code> 中. 后者则是分为了一个个 <code>rc-*</code> 的仓库, 如 <code>rc-form</code>, <code>rc-table</code>, …</p>
<p>这样实现的好处有, 一是提高了开发过程中的启动速度. 更重要的是, 我们可以单独的发布组件, 不用顾忌其他开发中的组件.</p>
<h3 id="版本号规范"><a href="#版本号规范" class="headerlink" title="版本号规范"></a>版本号规范</h3><p>我们会通过 npm publish 的 <code>tag</code> 来判断模块的当前状态.</p>
<p>在代码提交时, 如果 package.json 中 <code>version</code> 的值是 <code>1.0.0-alpha.1</code> 的形式. Jenkins 会通过脚本检测到 <code>alpha</code> 的字样, 采用 <code>npm publish --tag alpha</code> 的方式进行构建. 并在待提测的应用构建时, 将依赖替换为 <code>component@alpha</code>.</p>
<p>待组件测试通过, 我们就可以去掉 version 中 -alpha.x 的部分.</p>
<p>如果 package.json 的 version 没有包含 <code>-字符串</code>, 则 publish 不加 <code>--tag</code>参数, 会以默认的 tag <code>latest</code> 发布.</p>
<p>当然如果组件的 version 已经存在于 registry 中, Jenkins 则会跳过 publish 步骤.</p>
<p>对于正式上线的构建, Jenkins 会将所有依赖强制替换为 <code>latest</code> 的版本.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/engineering/a-plan-of-web-components/" data-id="cj7h2p99d000449m403fagpbs" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/engineering/a-plan-of-web-components/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/engineering/">engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/modules/">modules</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/webrtc/learn-webrtc-faq/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">WebRTC 学习 FAQ</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/engineering/">engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/framework/">framework</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/test/">test</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/webrtc/">webrtc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/apollo/">apollo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css-in-js/">css-in-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/engineering/">engineering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/modules/">modules</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/other/">other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/test/">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webrtc/">webrtc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/apollo/" style="font-size: 10px;">apollo</a> <a href="/blog/tags/css/" style="font-size: 13.33px;">css</a> <a href="/blog/tags/css-in-js/" style="font-size: 13.33px;">css-in-js</a> <a href="/blog/tags/engineering/" style="font-size: 16.67px;">engineering</a> <a href="/blog/tags/express/" style="font-size: 10px;">express</a> <a href="/blog/tags/js/" style="font-size: 10px;">js</a> <a href="/blog/tags/modules/" style="font-size: 10px;">modules</a> <a href="/blog/tags/node/" style="font-size: 10px;">node</a> <a href="/blog/tags/other/" style="font-size: 10px;">other</a> <a href="/blog/tags/react/" style="font-size: 20px;">react</a> <a href="/blog/tags/test/" style="font-size: 10px;">test</a> <a href="/blog/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/blog/tags/webrtc/" style="font-size: 10px;">webrtc</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/01/">January 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/engineering/a-plan-of-web-components/">前端组件化</a>
          </li>
        
          <li>
            <a href="/blog/webrtc/learn-webrtc-faq/">WebRTC 学习 FAQ</a>
          </li>
        
          <li>
            <a href="/blog/framework/learn-about-apollo/">[笔记]Apollo 初体验</a>
          </li>
        
          <li>
            <a href="/blog/webpack/some-about-webpack/">webpack 介绍</a>
          </li>
        
          <li>
            <a href="/blog/engineering/stop-using-css-in-js/">[译]停止使用 CSS-in-JS 的九个理由</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ekoneko<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'ekoneko';
  
  var disqus_url = 'http://ekoneko.github.io/blog/engineering/a-plan-of-web-components/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>