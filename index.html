<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ekoneko.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="ekoneko.github.io">
<meta property="og:url" content="http://ekoneko.github.io/blog/index.html">
<meta property="og:site_name" content="ekoneko.github.io">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ekoneko.github.io">
  
    <link rel="alternate" href="/atom.xml" title="ekoneko.github.io" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">ekoneko.github.io</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ekoneko.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-try-sentry" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/autotest/try-sentry/" class="article-date">
  <time datetime="2017-10-18T10:02:04.000Z" itemprop="datePublished">2017-10-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/autotest/">autotest</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/autotest/try-sentry/">[笔记]使用 sentry</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="sentry-介绍"><a href="#sentry-介绍" class="headerlink" title="sentry 介绍"></a>sentry 介绍</h2><p><a href="https://sentry.io/" target="_blank" rel="external">sentry</a> 是一个很流行的错误监控工具. 它能很好的监听线上异常以及开发者手动抛出的错误并记录.</p>
<p>除了官方提供的 sentry.io 外, 也支持自己部署 (<a href="https://zhuanlan.zhihu.com/p/24445449" target="_blank" rel="external">Sentry 简易搭建指南</a>), 适用于安全性有所要求的项目.</p>
<p>sentry 的界面看起来十分高大上. <code>Issues</code> 界面可以看到所有网站中抛出的异常(及开发者想记录的信息) 相同内容的记录会合并在一起并记录触发次数, 避免被某一个问题刷屏的情况. 也可以像 GitHub 的 issue 一样 assign 给相应的开发者处理. 并且 sentry 也支持邮寄和各种 IM 的 robot, 十分好用.</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>代码的不同版本, 会对应不同的 bug, sentry 中用 <code>release</code> 来标识一个代码包的当前版本. 理论上不同代码包应该对应一个唯一性的 release version</p>
<h2 id="sentry-配置"><a href="#sentry-配置" class="headerlink" title="sentry 配置"></a>sentry 配置</h2><p>想使用 sentry 首先要在 sentry.io (或是自建服务)上注册一个项目. 项目注册后会得到一个类似下面这样的 url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://abcdefghijklmn@sentry.io/12345</div></pre></td></tr></table></figure>
<p>用来作为监控的来源识别</p>
<p>参考<a href="https://docs.sentry.io/clients/javascript/install/" target="_blank" rel="external">官方文档</a>, 使用 sentry 需要引入其 sdk 脚本文件 ravenjs.</p>
<p>可以通过静态脚本引入</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.ravenjs.com/3.19.1/raven.min.js"</span> <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>也可以用 npm 等包管理软件引入 <code>npm install raven-js</code></p>
<p>加载 raven 后, 配置和之前注册项目的关联</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Raven</div><div class="line">    .config(<span class="string">'https://abcdefghijklmn@sentry.io/12345'</span>, &#123;</div><div class="line">      <span class="attr">release</span>: <span class="string">'your release'</span>,</div><div class="line">      <span class="comment">// and more config</span></div><div class="line">    &#125;)</div><div class="line">    .install();</div></pre></td></tr></table></figure>
<p>这里的 release 可以是任意字符串, 用于识别当前的代码的构建版本. 建议 webpack 每次打包时生成一个唯一的 release 号, 如使用项目 hash, git commit 或者简单的时间字符串等.</p>
<h2 id="解决-sourcemap"><a href="#解决-sourcemap" class="headerlink" title="解决 sourcemap"></a>解决 sourcemap</h2><p>处于保密考虑, 一般生产环境不会提供 sourcemap. 这样 js 抛出的错误信息对开发人员很不友好. 我们可以将 sourcemap 传到 sentry 上来解决这个问题.</p>
<p>官方提供了<a href="https://docs.sentry.io/api/" target="_blank" rel="external">一套 API 接口</a> 可以向指定的 release 上传文件. 这里推荐一个更简单的实现:</p>
<p>通过 <a href="https://github.com/40thieves/webpack-sentry-plugin" target="_blank" rel="external">webpack-sentry-plugin</a> 插件在 webpack 构建时完成阶段直接将制定规则的文件同步到 sentry 上:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plugins.push(<span class="keyword">new</span> SentryPlugin(&#123;                                                                  </div><div class="line">    <span class="attr">organization</span>: <span class="string">'ekoneko'</span>,                                                                     </div><div class="line">    <span class="attr">project</span>: <span class="string">'test'</span>,                                                                             </div><div class="line">    <span class="attr">apiKey</span>: <span class="string">'......'</span>,                  </div><div class="line">    <span class="attr">release</span>: <span class="string">''</span>,                                                                                     </div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>配置前, 还需要前往 <a href="https://sentry.io/api/" target="_blank" rel="external">sentry.io/api/</a> 生成一个 apiKey</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/autotest/try-sentry/" data-id="cj8zzysho0000rvm4ehja1xzo" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/autotest/try-sentry/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/sentry/">sentry</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-exp-electron" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/electron/exp-electron/" class="article-date">
  <time datetime="2017-09-20T16:57:34.000Z" itemprop="datePublished">2017-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/electron/">electron</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/electron/exp-electron/">[笔记]electron 实践笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近工作上需要把 web 上的内容打包成一个客户端, 以便于提供一些更好用户体验的功能. 我们的前端是目前比较标准的 webpack + react. 因此, 首先想到的是把 <code>webpack</code> 生成的文件丢进 <code>electron</code> 里运行.</p>
<p>看似很简单, 但实践还是踩了蛮多坑的. 当然一定程度上也是由于我个人对 electron 并不太熟悉, 各种实践也是一边摸索一边进行的…</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>electron 启动时会执行一个 js 脚本创建一个 node 进程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">electron ./main.js</div></pre></td></tr></table></figure>
<p>这个进程可以用于初始化 electron 应用. 并且控制窗口的打开与事件监听. 在官方文档里, 这个进程被称作 <code>Main Process</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">'electron'</span>)</div><div class="line"></div><div class="line"><span class="keyword">const</span> &#123; BrowserWindow &#125; = electron</div><div class="line"></div><div class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Load code/index.html page</span></div><div class="line">mainWindow.loadURL(<span class="string">'file://index.html'</span>)</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>
<p>通过 <code>loadURL</code> 打开的窗口, 基本上就是一个内嵌 chrome 内核的浏览器, 只不过 <code>electron</code> 还贴心的注入了一些 nodejs 的模块, 比如 <code>commonjs</code> 的 require/modules, <code>fs</code>, <code>path</code> 之类的. </p>
<p>这个浏览器窗口的进程在官方文档里, 被称作 <code>Renderer Process</code>.</p>
<p>主进程和渲染进程可以调用的 API 各不相同, 渲染进程里提供了一个 <a href="https://electron.atom.io/docs/api/remote/" target="_blank" rel="external"><code>romote</code></a> 的模块可以用来执行主模块里的东西.</p>
<p>通过这些接口, 我们可以做到许多浏览器做不到的事情, 比如本地文件的读写, 代理, cors, 设备驱动, 等等等等…</p>
        
          <p class="article-more-link">
            <a href="/blog/electron/exp-electron/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/electron/exp-electron/" data-id="cj8zzybco0000ram4v3z9zqk1" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/electron/exp-electron/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/electron/">electron</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/note/">note</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learn-webrtc-faq" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/webrtc/learn-webrtc-faq/" class="article-date">
  <time datetime="2017-08-10T16:21:33.000Z" itemprop="datePublished">2017-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/webrtc/">webrtc</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/webrtc/learn-webrtc-faq/">[笔记]WebRTC 学习 FAQ</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Q: WebRTC 是什么, 能做什么, 社区评价?</p>
<p><a href="https://www.zhihu.com/question/22301898" target="_blank" rel="external">https://www.zhihu.com/question/22301898</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebRTC 全称 Web Real-Time Communication。它并不是单一的协议， 包含了媒体、加密、传输层等在内的多个协议标准以及一套基于 JavaScript 的 API。通过简单易用的 JavaScript API ，在不安装任何插件的情况下，让浏览器拥有了 P2P音视频和数据分享的能力。</div></pre></td></tr></table></figure>
<p>Q: WebRTC 技术栈</p>
<p><img src="https://upaiyun.kf5.com/attachments/download/3778945/0015971b5681d322f5e5212cb38cd7f/"></p>
<p>Q: 如何搭建一个 WebRTC sample?</p>
<p><a href="https://webrtc.github.io/samples/" target="_blank" rel="external">https://webrtc.github.io/samples/</a></p>
<p>Q: WebRTC有哪些实现?</p>
<p><a href="https://github.com/rainzhaojy/blogs/issues/3" target="_blank" rel="external">https://github.com/rainzhaojy/blogs/issues/3</a></p>
<ol>
<li>Browser Support</li>
<li>WebRTC native code (<a href="https://webrtc.org/native-code/" target="_blank" rel="external">https://webrtc.org/native-code/</a>)</li>
</ol>
<p>Q: WebRTC 如何进行网络请求?</p>
<p>通过 P2P 协议</p>
<p><a href="https://bloggeek.me/4-p2p-webrtc-facts/" target="_blank" rel="external">https://bloggeek.me/4-p2p-webrtc-facts/</a></p>
<ol>
<li>WebRTC 在 p2p 上和 voIp 一样<br> 这意味着从一端到另外一端是 “best effort” 的机制</li>
<li>WebRTC 是唯一的浏览器 p2p 方案</li>
<li>P2P 还是需要 STUN and TURN</li>
<li>WebRTC 还是需要外部信号协议</li>
</ol>
        
          <p class="article-more-link">
            <a href="/blog/webrtc/learn-webrtc-faq/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/webrtc/learn-webrtc-faq/" data-id="cj8zzyshq0001rvm4nqxzqtjk" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/webrtc/learn-webrtc-faq/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/webrtc/">webrtc</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learn-about-apollo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/framework/learn-about-apollo/" class="article-date">
  <time datetime="2017-07-31T14:31:06.000Z" itemprop="datePublished">2017-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/framework/">framework</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/framework/learn-about-apollo/">[笔记]Apollo 初体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>趁着 GitHub 的 Api 转向 GraphQL 时, 了解了下相关知识和其中一个蛮有名气的实现: Apollo.</p>
<p>先简单的唠叨两句, 相对比 Rest 和 GraphQL, 我觉得后者比较适合 Full-stack 框架的设计. 前端定义好的 SQL 可以完美对应 FE 的 model 层以及生成 PropTypes 或是 TypeScript 的类型定义. 而且 web app 接口的变化大多时候是前端驱动的, GraphQL 的特点之一, 业务带来的字段与查询变化, 开发人员可以优先专注前端, generate 出相应的接口与数据模型.</p>
<p>发布时, 如果前后端的规则一致, 也可以对两端同时编译, 将前端 GraphQL 的细节抽象, 转换为类似 Rest 的接口形式. 避免了请求包含字段细节从而增加安全性, 以及不用去烦恼前后端通讯的 graphQL 大小.</p>
<p>说到底, 想要发挥 GraphQL 的优势, 需要一套能 carry 全场的 graphql-generator 工具, 然而凭借我(两三天)对 graphql 的了解, 目前尚没有发现特别通用的工具.</p>
        
          <p class="article-more-link">
            <a href="/blog/framework/learn-about-apollo/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/framework/learn-about-apollo/" data-id="cj8zzvlz7000bp3m4v1u59aeh" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/framework/learn-about-apollo/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/apollo/">apollo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-some-about-webpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/webpack/some-about-webpack/" class="article-date">
  <time datetime="2017-07-22T16:10:48.000Z" itemprop="datePublished">2017-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/webpack/">webpack</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/webpack/some-about-webpack/">webpack 介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="模块化的前身今世"><a href="#模块化的前身今世" class="headerlink" title="模块化的前身今世"></a>模块化的前身今世</h2><p>近年随着硬件升级以及网络普及, 互联网应用的重心慢慢向富客户端偏移. 前端开发与构建也开始遇到了和其他语言相似的挑战: 代码复用, 关注分离以及灵活的继承.</p>
<p>社区的主流趋势是在 JavaScript 中引入模块化的概念以及一个模块加载系统. 目前主流的模块管理有 <code>AMD</code>, <code>CommonJs</code> 以及 ES6 规范的 <code>import</code></p>
<p>由于浏览器加载 script 异步的天性, 最先(也是最自然)诞生的模块是 <code>异步模块定义(Asynchronous Module Definition)</code>, 简称 <code>AMD</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">define([&apos;myDep&apos;, &apos;jquery&apos;], function(myDep, $) &#123;...&#125;)</div></pre></td></tr></table></figure>
<p><code>AMD</code> 通过一个数组声明自己所依赖的文件,当所有依赖加载完毕后, 作为参数传递给回调函数. <code>RequireJs</code> 是一个 <code>AMD</code> 比较常见的实现. 类似的还有国人玉伯写的 <code>Sea.js</code>(虽然 Sea.js 提出了 <code>CMD</code> 的概念, 但本质还是 AMD 的变形).</p>
<p><code>AMD</code> 允许以 runtime 的形式运行, 动态的加载依赖文件, 也可以一次性将依赖构建在一个或多个文件中运行, 后者在生产环境下使用较为普遍, 可以有效的优化页面加载速度, 例如 <code>Require.js</code> 提供的 <code>r.js</code>, 在 CLI 中执行可以将源码构建并优化成生产环境运行的目标代码, 写入指定目录, 这一点已经和 webpack 比较相似了.</p>
<p>另外值得一提的是 <code>Require.js</code> 并不仅仅可以处理 js 模块, 还可以用于引入 css, 文本资源等等. 通过一些 <code>Require.js</code> 的插件来实现, 在代码中也需要显示的声明文件类型 (eg: <code>require(&#39;css!style.css&#39;)</code>). 相比日后 webpack 要繁琐些.</p>
<p>CommonJs 是 nodejs 默认的加载方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const $ = require(‘jQuery’);</div><div class="line">console.log($.version);</div></pre></td></tr></table></figure>
<p>这种同步的写法在浏览器中显然无法直接运行. 但我们可以在构建阶段将 js 文本解析成<code>抽象语法树(Abstract Syntax Tree)</code>, 然后将所有 require 的内容合并在一个文件中. 这样的解析工具有 <code>Browserify</code> 以及后来的 <code>Webpack</code>.</p>
<p><code>Webpack</code> 在 <code>Browserify</code> 基础上做了一些优化, 比如可以将构建的文件拆分成多个 <code>chunk</code>, 不用刷新页面就可以’热替换’模块等.</p>
<p>ES6 的 import 实际上和 CommonJs 比较相似, 不单独赘述.</p>
<p><code>AMD</code> 需要把真正的代码放入一个回调函数中, 很多类库在文件头部会出现判断是否存在 define 和 define.amd 的判断逻辑然后分别调以不同的模块加载方式. 相较之下, <code>CommonJs</code> 和 <code>ES6 import</code> 的用法对于源码破坏性要小的多, 也更符合其他语言的模块加载逻辑.</p>
        
          <p class="article-more-link">
            <a href="/blog/webpack/some-about-webpack/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/webpack/some-about-webpack/" data-id="cj8zzvlza000hp3m4a2afd7ll" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/webpack/some-about-webpack/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-stop-using-css-in-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/engineering/stop-using-css-in-js/" class="article-date">
  <time datetime="2017-06-18T14:52:27.000Z" itemprop="datePublished">2017-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/engineering/">engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/engineering/stop-using-css-in-js/">[译]停止使用 CSS-in-JS 的九个理由</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文: [<a href="https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc" target="_blank" rel="external">https://medium.com/@gajus/stop-using-css-in-javascript-for-web-development-fa32fb873dcc</a>]</p>
<p>原文发表于: 2016-04-27</p>
<p>最近社区上 CSS-in-JS 与 CSS-Module 的争论持续不断, 上一篇译文<a href="https://ekoneko.github.io/blog/engineering/a-unified-styling-language/">统一样式语言</a> 介绍了关于 CSS-in-JS 的优点. 本篇则是站在反对者的观点上, 反驳了一些(作者认为上的) CSS-in-JS 误区.</p>
<h2 id="关于-CSS"><a href="#关于-CSS" class="headerlink" title="关于 CSS"></a>关于 CSS</h2><p><code>styled-components</code> 的文档说</p>
<pre><code>原始 CSS 是用于文档形式的 web 的. 在1993年, 网页都是一些静态的文档, 那时用 CSS 来解决文档的样式问题. 如今, 我们构建的是更加丰富, 可交互, 面向用户的 APP. CSS 已经不适合构建这样的项目
</code></pre><p>我不赞同. CSS 也在与时俱进加入了许多新功能. (伪类, 伪元素, CSS 变量, \@media, 帧动画, 组合, 列, flex, 网格, calc, etc…)</p>
<p>从 UI 的角度上, “组件”就是独立的文档碎片. (比如 &lt;button /&rt;就是一个组件) CSS 用来描述文档, 也就是所有组件的集合, 有何不妥呢. 正所谓物尽其用.</p>
<h2 id="Styled-components"><a href="#Styled-components" class="headerlink" title="Styled-components"></a>Styled-components</h2><p><code>styled-components</code> 允许使用模板文本的方式在 JS 中定义 CSS. 通过一种底层构建的方法取消了组件与样式组件之间的关系. <a href="https://www.webpackbin.com/bins/-KeeZCr0xKfutOfOujxN" target="_blank" rel="external">demo</a></p>
<p>这成为了 React 中一种新型定义组件样式的趋势.</p>
<p>先明确一点: styled-components 组件是 CSS 的高阶抽象. 它在 JS 中定义 CSS, 并在 JSX 解析时绑定在对应元素上.</p>
<p>我不喜欢这种趋势, 它充满了太多误解. 调查了IRC, reddit, discord等地方, 人们用 <code>styled-components</code> 的理由. 我把他们称为”幻想” (myths)</p>
        
          <p class="article-more-link">
            <a href="/blog/engineering/stop-using-css-in-js/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/engineering/stop-using-css-in-js/" data-id="cj8zzvlzd000op3m4gqmg2xkm" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/engineering/stop-using-css-in-js/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/css-in-js/">css-in-js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/engineering/">engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-a-unified-styling-language" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/engineering/a-unified-styling-language/" class="article-date">
  <time datetime="2017-06-05T00:07:30.000Z" itemprop="datePublished">2017-06-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/engineering/">engineering</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/engineering/a-unified-styling-language/">[译]统一样式语言</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文: [<a href="https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660" target="_blank" rel="external">https://medium.com/seek-blog/a-unified-styling-language-d0c208de2660</a>]</p>
<p>原文发表于: 2017-05-23</p>
<p>近几年里我们看到了很多 <a href="https://github.com/MicheleBertoli/css-in-js" target="_blank" rel="external"><code>css in js</code></a> 的尝试.<br>大多来自 React 社区. 显然这遭到了很多的吐槽, 尤其是那些非常熟练 css 的人, 觉得这种行为难以置信</p>
<pre><code>&quot;为什么会有人想把 css 写在 js 里?&quot;
&quot;这绝对是糟糕的主意!&quot;
&quot;如果他们学过 css 的话!&quot;
</code></pre><p>如果这是你的第一反应, 那么请读下去. 我们需要继续讨论为什么把 css 写在 js 里并不那么糟糕, 以及为什么我们要着眼于此.</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*Ipu5Grtzr21suPiTfvGXaw.png"></p>
<h2 id="社区的误解"><a href="#社区的误解" class="headerlink" title="社区的误解"></a>社区的误解</h2><p>我从19岁就开始从事 css 专业, 在那个用表格布局的黑暗年代. 按照 <a href="http://www.csszengarden.com/" target="_blank" rel="external">CSS Zen Garden</a> 中受到启发, 我将过去的代码迁移到语义标签下并使用样式表布局.<br>不久之后，我开始痴迷于分离样式，使用<a href="https://www.w3.org/wiki/The_principles_of_unobtrusive_JavaScript" target="_blank" rel="external">不起眼的JavaScript</a>来装饰服务器渲染的标记与客户端交互. 有一个小但是活跃的社区从事着这样的实践, 我们成为了第一批前端工程师.</p>
<p>或许你会认为我会反对 React 的 HTML-in-JS, 因为这和我之前的所做完全相反. 在我的经验里, React组件模型及其服务端渲染能力, 最终可以构建一个复杂的单页应用, 从而让我们可以向用户提供快速, 可达, 渐进增强的应用. 我在 <code>Seek</code> 实践了这样的能力, 通过 React 构建了单页面应用, 即使禁用了 js, 搜索依旧可用, 并且通过服务端渲染在旧的浏览器中可以正常工作</p>
<p>所以让两个社区和平共处的橄榄枝是什么呢, 虽然这种方式并不完美, 没有被你用于生产环境, 甚至不是很有说服力, 但至少可以带给我们思考空间.</p>
<h2 id="Why-CSS-in-JS"><a href="#Why-CSS-in-JS" class="headerlink" title="Why CSS-in-JS?"></a>Why CSS-in-JS?</h2><p>希望通过范围控制样式的开发者通常喜欢直接使用 CSS 模块, 而非 CSS-in-JS. 我在工作项目也没有使用 CSS-in-JS.</p>
<p>尽管如此我也实时关注 CSS-in-JS社区, 并且我也认为应当如此.</p>
<p>但是为什么需要 CSS-in-JS 呢?</p>
<p>为了清楚这个问题, 我们将讨论这种做法带来的好处:</p>
<ol>
<li>范围约束</li>
<li>关键样式 (Critical CSS)</li>
<li>更智能的优化</li>
<li>包管理</li>
<li>非浏览器平台样式 (Non-browser styling)</li>
</ol>
        
          <p class="article-more-link">
            <a href="/blog/engineering/a-unified-styling-language/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/engineering/a-unified-styling-language/" data-id="cj8zzvlz40005p3m406qpox9m" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/engineering/a-unified-styling-language/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/css-in-js/">css-in-js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/engineering/">engineering</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-how-to-better-organize-your-react-app" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/react/how-to-better-organize-your-react-app/" class="article-date">
  <time datetime="2017-05-06T14:58:53.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/react/">react</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/react/how-to-better-organize-your-react-app/">[译]如何更好的组织 React 应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文 Url: <a href="https://medium.com/@alexmngn/how-to-better-organize-your-react-applications-2fd3ea1920f1" target="_blank" rel="external">https://medium.com/@alexmngn/how-to-better-organize-your-react-applications-2fd3ea1920f1</a></p>
<hr>
<p>最近几年我和十余个同伴一起致力于大型项目从零开始的开发和维护. 有时候,没有一个良好的架构很难维持代码组织</p>
<p>注1: 我的例子中都使用了 redux, 如果你不了解, 参考 <a href="http://redux.js.org/" target="_blank" rel="external">redux文档</a></p>
<p>注2: 所有的例子都基于 react, 但在 react native 中可以保持相同的结构</p>
<h2 id="创建一个应用有哪些挑战"><a href="#创建一个应用有哪些挑战" class="headerlink" title="创建一个应用有哪些挑战?"></a>创建一个应用有哪些挑战?</h2><p>这是一个发生或将发生在所有开发者项目中的事情:</p>
<ol>
<li><p>你和几个开发者开始为客户开发一个应用, 一切都很美好</p>
</li>
<li><p>你的客户提了几个新需求, 嗯, 加上了</p>
</li>
<li><p>你的客户又要求去掉几个功能, 并加上一些新功能, 有点棘手但并不难实现. 项目开始变得不那么完美</p>
</li>
<li><p>你的客户继续要求增加/修改/删除需求, 你开始在一些代码上打补丁. 代码不再让人骄傲, 但还能用</p>
</li>
<li><p>6个月后, 代码变得复杂, 难以理解, 像一团意大利面条</p>
</li>
</ol>
<p>直到有一天客户要求推出一个新版本时, 你放弃了乱成一团的旧代码, 开始了一个新的项目</p>
        
          <p class="article-more-link">
            <a href="/blog/react/how-to-better-organize-your-react-app/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/react/how-to-better-organize-your-react-app/" data-id="cj8zzvlz60009p3m44oycy8yp" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/react/how-to-better-organize-your-react-app/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-diy-develop-tools-by-ast" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/tools/diy-develop-tools-by-ast/" class="article-date">
  <time datetime="2017-04-12T16:51:40.000Z" itemprop="datePublished">2017-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/tools/">tools</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/tools/diy-develop-tools-by-ast/">开发基于 AST 的前端工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在遇到了两个小需求:</p>
<ol>
<li>要给一个已开发完的项目进行国际化, 希望可以遍历获取代码中注释之外的中文文本</li>
<li>一个较为复杂的项目希望在编译阶段根据代码中的特殊格式语句控制代码执行</li>
</ol>
<p>这两个需求本质上比较接近: 都是对代码本身进行分析与处理. 而对于代码这种文本的处理, 用正则就太麻烦了. 不仅要考虑上下文的关系, 还要括号配对的行为. 将代码转换成<code>抽象语法树</code>再进行处理则要方便的多.</p>
<p>按照<a href="https://zh.wikipedia.org/zh-hans/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9" target="_blank" rel="external">维基百科</a>的定义:</p>
<pre><code>在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。 树上的每个节点都表示源代码中的一种结构。
</code></pre><p>简单说来 AST 就是将整个代码作为一个根节点, 其中的每一个表达式作为一个子节点, 表达式内部, 又是由若干表达式与字符, 操作符作为子节点, 一点点细分直到所有单独的文本或操作符作为叶子节点… (怀念大学操作系统前几章的介绍<code>状态机</code>解析程序语言的部分)</p>
<p>生成 AST 的过程我们不需要手工完成, 像是 <code>acorn</code>, <code>babylon</code> 等许多模块都可以实现代码文本向 AST 的转换. 本文就是基于 <code>babylon</code> 实现的. 大部分的 AST 解析器功能和思路都比较接近, 我选择 <code>babylon</code> 的原因是 <code>babylon</code> 直接支持 JSX 语法的转译, 对于我们 React 的项目来说省去了很多麻烦.</p>
<h2 id="babylon"><a href="#babylon" class="headerlink" title="babylon"></a>babylon</h2><p><a href="https://www.npmjs.com/package/babylon" target="_blank" rel="external"><code>babylon</code></a> 是 <code>babel</code> 内的 JavaScript 语法分析器. 作为一个功能独立的库, 也可以在 <code>babel</code> 之外调用, 例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function parse (text, filePath) &#123;</div><div class="line">  try &#123;</div><div class="line">    return babylon.parse(text, &#123;</div><div class="line">      plugins: [&apos;jsx&apos;, &apos;classProperties&apos;],</div><div class="line">    &#125;)</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    throw new Error(`Parse error: in $&#123;filePath&#125;`, e)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>babylon.parse(code, [options])</code> 会将代码字符串转译成 AST. 参数中的 <code>plugins</code> 是 <code>babylon</code> 内置的一些 ECMA 标准外的其他常用语法的支持. 我的工具打算运行在 <code>React</code> 项目上, <code>jsx</code> 插件可以解析 jsx 语法, 以及 <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="external">classProperties</a>插件提供一些 ES6 标准之外的语法支持.</p>
<h3 id="babylon-walk"><a href="#babylon-walk" class="headerlink" title="babylon-walk"></a>babylon-walk</h3><p>babylon 也提供了一个 <a href="https://www.npmjs.com/package/babylon-walk" target="_blank" rel="external"><code>babylon-walk</code></a> 的工具来遍历语法树.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const walk = require(&apos;babylon-walk&apos;);</div><div class="line">const visitors = &#123;</div><div class="line">  StringLiteral: func,</div><div class="line">  JSXText: func,</div><div class="line">&#125;</div><div class="line">const state = &#123;&#125;</div><div class="line">walk.simple(node, visitors, state);</div></pre></td></tr></table></figure>
<p><code>node</code>是待遍历的 ast 节点, 如果需要遍历整个代码只需传递根节点就好</p>
<p><code>visitors</code> 是一个 nodeType 与回调函数的对应表. 遍历时如果一个节点的类型存在对应的 visitors, <code>babylon-walk</code> 就会调用对应的回调函数, 并传递 <code>node</code> 和 <code>state</code></p>
<p><code>state</code> 是一个普通的 object, 或是其他任何东西. 他的作用是在遍历途中保存一些需要的东西, 而不需要在 walk 的作用域外创建一个变量</p>
<p><code>babylon-walk</code> 除上面用到的<code>simple</code>, 一共支持三种遍历模式:</p>
<ol>
<li><code>sample</code>: 最普通的遍历</li>
<li><code>ancestor</code>: 回调函数中会附加所有遍历的先代节点信息</li>
<li><code>recursive</code>: 遍历时根据回调函数的返回值选择继续遍历的子节点</li>
</ol>
        
          <p class="article-more-link">
            <a href="/blog/tools/diy-develop-tools-by-ast/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/tools/diy-develop-tools-by-ast/" data-id="cj8zzvlyz0001p3m4n5zzmtqt" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/tools/diy-develop-tools-by-ast/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/other/">other</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-performance-engineering-with-react" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/react/performance-engineering-with-react/" class="article-date">
  <time datetime="2017-03-28T15:22:07.000Z" itemprop="datePublished">2017-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/react/">react</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/react/performance-engineering-with-react/">[译]React 性能工程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是 React 性能工程系列的第一部分, 第二部分见<a href="http://benchling.engineering/deep-dive-react-perf-debugging/" target="_blank" rel="external">深入了解 React 性能调试</a></p>
<p>本文是为了复杂的 react 项目. 如果你只是在做一些小型项目, 当还没有面临性能问题时, 请不要考虑优化, 只要构建就好了!</p>
<p>然而, 当开始写一些 DNA 设计工具啦, 凝胶图像分析软件啦, 富文本编辑器或是功能完备的表格系统时, 免不了会遇见性能瓶颈, 并需要尝试寻找解决之道, 本文就是尝试分享我们在此类问题上的一点经验.</p>
<p>本文中, 我将介绍 react 性能分析的基本工具, 一些导致性能瓶颈的常见问题, 调试上的一些关键点.</p>
<h2 id="React-性能基础"><a href="#React-性能基础" class="headerlink" title="React 性能基础"></a>React 性能基础</h2><p>用3句话概述浏览器性能: 理想下浏览器渲染是60帧/秒, 即 16.7ms 一帧. 当应用较慢, 通常用户事件, 数据处理会有较长的延迟. 多数情况并不会有复杂的数据处理, 大部分事件会浪费在重新渲染上.</p>
<p>使用 React 可以不做额外工作下立即一些性能优化.</p>
<p>因为 React 托管了所有 DOM 操作, 多数情况下 DOM 的解析与布局问题都可以被避免. 屏幕背后, React 维护了一套虚拟DOM 的机制, 使文档在最小的改变下让文档变回被期待的样子.</p>
<p>由于 React组件在 JavaScript 里存储状态, 不建议访问直接操作 DOM. 一个比较常见的例子是在不恰当的时机访问了一个 DOM, 然后导致了<a href="https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/analyze-runtime#how-to-identify-layout-bottlenecks" target="_blank" rel="external">强制布局同步</a> (e.g. <code>someNode.style.left</code>浏览器会强制渲染一个 frame). 代替这种做法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">someNode.style.left = parseInt(someNode.style.left) + 10 + &quot;px&quot;;</div></pre></td></tr></table></figure>
<p>我们声明了 <code>&lt;SomeComponent style={ {left: this.state.left} } /&gt;</code>, 然后通过更新 state 而非读取 DOM 的方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.setState(&#123;left: this.state.left + 10&#125;).</div></pre></td></tr></table></figure>
<p>这些性能优化点并不局限于 React, 建议在做其他事情前先解决此类问题.</p>
<p>简单的 React 应用这些就足够, 在复杂的应用中, 虚拟 DOM 的对比可能成为昂贵的开销. 幸运的是 React 提供了一些性能检测工具来发现并防范问题.</p>
<h2 id="调试带来的性能问题"><a href="#调试带来的性能问题" class="headerlink" title="调试带来的性能问题"></a>调试带来的性能问题</h2><p>小心, 一些调试本身就会带来间接成本. 不要在开发环境下调试.</p>
<h3 id="ELEMENTS-窗口"><a href="#ELEMENTS-窗口" class="headerlink" title="ELEMENTS 窗口"></a>ELEMENTS 窗口</h3><p>(Chrome dev tools 上的) Elements 面板可以方便直观的看到什么元素被重新渲染了, 当属性变化或一个DOM 节点 被更新/新增/替换时会有一个闪烁的效果. 但是这种检测本身会影响到性能, 如果要准确计算 FPS 时, 请切换到 Consoles 面板.</p>
<h3 id="PROPTYPES"><a href="#PROPTYPES" class="headerlink" title="PROPTYPES"></a>PROPTYPES</h3><p>React 开发中, <a href="PropType validation">PropType 校验</a> 发生在组件被渲染时.利用 Chrome dev tools 上的Profiler面板可以观察到 React 组件花费了大量时间在校验(validate)的方法上</p>
<p>虽然开发工具的警告在调试阶段很有用, 但是生产环境下缺造成了额外的开销. 有时我会切换到生产模式来忽略这个延迟</p>
        
          <p class="article-more-link">
            <a href="/blog/react/performance-engineering-with-react/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://ekoneko.github.io/blog/react/performance-engineering-with-react/" data-id="cj8zzvlzc000mp3m49zrnn2dd" class="article-share-link">Share</a>
      
        <a href="http://ekoneko.github.io/blog/react/performance-engineering-with-react/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/autotest/">autotest</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/electron/">electron</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/engineering/">engineering</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/framework/">framework</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/react/">react</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/test/">test</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/tools/">tools</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/webrtc/">webrtc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/apollo/">apollo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css-in-js/">css-in-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/electron/">electron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/engineering/">engineering</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/express/">express</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/node/">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/note/">note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/other/">other</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/sentry/">sentry</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/test/">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webrtc/">webrtc</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/apollo/" style="font-size: 10px;">apollo</a> <a href="/blog/tags/css/" style="font-size: 15px;">css</a> <a href="/blog/tags/css-in-js/" style="font-size: 15px;">css-in-js</a> <a href="/blog/tags/electron/" style="font-size: 10px;">electron</a> <a href="/blog/tags/engineering/" style="font-size: 15px;">engineering</a> <a href="/blog/tags/express/" style="font-size: 10px;">express</a> <a href="/blog/tags/js/" style="font-size: 10px;">js</a> <a href="/blog/tags/node/" style="font-size: 10px;">node</a> <a href="/blog/tags/note/" style="font-size: 10px;">note</a> <a href="/blog/tags/other/" style="font-size: 10px;">other</a> <a href="/blog/tags/react/" style="font-size: 20px;">react</a> <a href="/blog/tags/sentry/" style="font-size: 10px;">sentry</a> <a href="/blog/tags/test/" style="font-size: 10px;">test</a> <a href="/blog/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/blog/tags/webrtc/" style="font-size: 10px;">webrtc</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2014/01/">January 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/autotest/try-sentry/">[笔记]使用 sentry</a>
          </li>
        
          <li>
            <a href="/blog/electron/exp-electron/">[笔记]electron 实践笔记</a>
          </li>
        
          <li>
            <a href="/blog/webrtc/learn-webrtc-faq/">[笔记]WebRTC 学习 FAQ</a>
          </li>
        
          <li>
            <a href="/blog/framework/learn-about-apollo/">[笔记]Apollo 初体验</a>
          </li>
        
          <li>
            <a href="/blog/webpack/some-about-webpack/">webpack 介绍</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ekoneko<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'ekoneko';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>